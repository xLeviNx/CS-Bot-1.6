name: Build CS-Bot Cross-Platform

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master, develop ]
  release:
    types: [published]

jobs:
  build-windows:
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive
    
    - name: Setup MSVC
      uses: microsoft/setup-msbuild@v2
    
    - name: Setup Visual Studio environment
      uses: TheMrMilchmann/setup-msvc-dev@v3
      with:
        arch: x86
    
    - name: Create build directory
      run: mkdir build-windows
    
    - name: Configure CMake (if CMakeLists.txt exists)
      run: |
        if (Test-Path "CMakeLists.txt") {
          cd build-windows
          cmake .. -G "Visual Studio 17 2022" -A Win32 -DCMAKE_BUILD_TYPE=Release
        }
      shell: powershell
    
    - name: Build with CMake
      run: |
        if (Test-Path "CMakeLists.txt") {
          cd build-windows
          cmake --build . --config Release --parallel
        }
      shell: powershell
    
    - name: Upgrade project toolset and build with MSBuild
      run: |
        $slnFiles = Get-ChildItem -Path . -Filter "*.sln" -Recurse
        $vcxprojFiles = Get-ChildItem -Path . -Filter "*.vcxproj" -Recurse
        
        # First, retarget the solution to use current toolset
        if ($slnFiles.Count -gt 0) {
          foreach ($sln in $slnFiles) {
            Write-Host "Retargeting solution: $($sln.FullName)"
            & "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\IDE\devenv.exe" $sln.FullName /upgrade
            
            Write-Host "Building solution: $($sln.FullName)"
            msbuild $sln.FullName /p:Configuration=Release /p:Platform=Win32 /p:PlatformToolset=v143 /m
          }
        } elseif ($vcxprojFiles.Count -gt 0) {
          foreach ($proj in $vcxprojFiles) {
            Write-Host "Building project: $($proj.FullName)"
            msbuild $proj.FullName /p:Configuration=Release /p:Platform=Win32 /p:PlatformToolset=v143 /m
          }
        }
      shell: powershell
    
    - name: Build with Make (MinGW fallback)
      run: |
        if (Test-Path "Makefile") {
          choco install mingw -y
          $env:PATH += ";C:\tools\mingw64\bin"
          make clean
          make PLATFORM=win32
        }
      shell: powershell
    
    - name: Find and collect Windows artifacts
      run: |
        $artifacts = @()
        
        # Search in common output directories first
        $searchPaths = @(".", "Release", "Debug", "bin", "lib", "output", "build", "module\Release", "module\Debug", "module\msvc\Release", "module\msvc\Debug")
        
        foreach ($path in $searchPaths) {
          if (Test-Path $path) {
            Write-Host "Searching in: $path"
            $found = Get-ChildItem -Path $path -Filter "*.dll" -Recurse -ErrorAction SilentlyContinue
            $artifacts += $found
            
            foreach ($file in $found) {
              Write-Host "Found DLL: $($file.FullName)"
            }
          }
        }
        
        if ($artifacts.Count -eq 0) {
          Write-Host "No DLL files found, searching for all build outputs..."
          $artifacts = Get-ChildItem -Path . -Filter "*.dll" -Recurse -ErrorAction SilentlyContinue
          $artifacts += Get-ChildItem -Path . -Filter "*.exe" -Recurse -ErrorAction SilentlyContinue
        }
        
        New-Item -ItemType Directory -Force -Path "windows-artifacts"
        
        if ($artifacts.Count -eq 0) {
          Write-Host "No artifacts found, creating build log for debugging"
          "Build completed but no DLL files were generated" | Out-File "windows-artifacts\build_log.txt"
          "Directory structure:" | Out-File "windows-artifacts\build_log.txt" -Append
          Get-ChildItem -Recurse -Include "*.vcxproj", "*.sln", "*.c", "*.cpp", "*.h" | ForEach-Object { $_.FullName } | Out-File "windows-artifacts\build_log.txt" -Append
        } else {
          foreach ($artifact in $artifacts) {
            Copy-Item $artifact.FullName -Destination "windows-artifacts\"
            Write-Host "Collected: $($artifact.Name)"
          }
        }
      shell: powershell
    
    - name: Upload Windows artifacts
      uses: actions/upload-artifact@v4
      with:
        name: windows-build
        path: windows-artifacts/
        retention-days: 30
      if: always()  # Upload even if build partially failed

  build-linux:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive
    
    - name: Install 32-bit development tools
      run: |
        sudo dpkg --add-architecture i386
        sudo apt-get update
        sudo apt-get install -y \
          gcc-multilib \
          g++-multilib \
          libc6-dev-i386 \
          build-essential \
          cmake
    
    - name: Create build directory
      run: mkdir -p build-linux
    
    - name: Configure CMake (if CMakeLists.txt exists)
      run: |
        if [ -f "CMakeLists.txt" ]; then
          cd build-linux
          cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_FLAGS="-m32" -DCMAKE_CXX_FLAGS="-m32"
        fi
    
    - name: Build with CMake
      run: |
        if [ -f "CMakeLists.txt" ]; then
          cd build-linux
          cmake --build . --config Release --parallel $(nproc)
        fi
    
    - name: Build with Make
      run: |
        if [ -f "Makefile" ]; then
          make clean || true
          make PLATFORM=linux ARCH=i386 -j$(nproc)
        elif [ -f "module/Makefile" ]; then
          cd module
          make clean || true  
          make PLATFORM=linux ARCH=i386 -j$(nproc)
        elif [ -f "src/Makefile" ]; then
          cd src
          make clean || true
          make PLATFORM=linux ARCH=i386 -j$(nproc)
        fi
    
    - name: Find and collect Linux artifacts
      run: |
        mkdir -p linux-artifacts
        
        echo "Searching for .so files in the entire repository..."
        find . -name "*.so" -type f -print | while read file; do
          echo "Found .so file: $file"
          cp "$file" linux-artifacts/
          echo "Copied: $(basename $file)"
        done
        
        # Also look in common build directories
        for dir in Release Debug bin lib output build module/Release module/Debug; do
          if [ -d "$dir" ]; then
            echo "Checking directory: $dir"
            find "$dir" -name "*.so" -o -name "*.dll" -o -name "*csbot*" | while read file; do
              echo "Found in $dir: $file"
              cp "$file" linux-artifacts/ 2>/dev/null || true
            done
          fi
        done
        
        # If still no artifacts, create a placeholder to prevent upload failure
        if [ ! "$(ls -A linux-artifacts 2>/dev/null)" ]; then
          echo "No artifacts found, creating build log for debugging"
          echo "Build completed but no .so files were generated" > linux-artifacts/build_log.txt
          echo "Directory structure:" >> linux-artifacts/build_log.txt
          find . -name "*.c" -o -name "*.cpp" -o -name "*.h" -o -name "Makefile" -o -name "*.so" >> linux-artifacts/build_log.txt
        fi
        
        echo "Final artifacts directory contents:"
        ls -la linux-artifacts/
    
    - name: Upload Linux artifacts
      uses: actions/upload-artifact@v4
      with:
        name: linux-build
        path: linux-artifacts/
        retention-days: 30
      if: always()  # Upload even if build partially failed

  create-release:
    needs: [build-windows, build-linux]
    runs-on: ubuntu-latest
    if: github.event_name == 'release' && github.event.action == 'published'
    
    steps:
    - name: Download Windows artifacts
      uses: actions/download-artifact@v4
      with:
        name: windows-build
        path: windows-build/
    
    - name: Download Linux artifacts  
      uses: actions/download-artifact@v4
      with:
        name: linux-build
        path: linux-build/
    
    - name: Create release package
      run: |
        mkdir -p release-package/addons/csbot_enabler
        
        # Copy Windows binaries
        find windows-build -name "*.dll" -exec cp {} release-package/addons/csbot_enabler/ \;
        
        # Copy Linux binaries  
        find linux-build -name "*.so" -exec cp {} release-package/addons/csbot_enabler/ \;
        
        # Create archive
        cd release-package
        zip -r ../csbot-enabler-${{ github.event.release.tag_name }}.zip .
        tar -czf ../csbot-enabler-${{ github.event.release.tag_name }}.tar.gz .
    
    - name: Upload release assets
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url }}
        asset_path: ./csbot-enabler-${{ github.event.release.tag_name }}.zip
        asset_name: csbot-enabler-${{ github.event.release.tag_name }}.zip
        asset_content_type: application/zip
    
    - name: Upload release tar.gz
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url }}
        asset_path: ./csbot-enabler-${{ github.event.release.tag_name }}.tar.gz
        asset_name: csbot-enabler-${{ github.event.release.tag_name }}.tar.gz
        asset_content_type: application/gzip
